import scala.annotation.tailrec

object DaysOfTheWeek {
  def main(args: Array[String]): Unit ={
    var daysArray = Array("Poniedziałek", "Wtorek", "Środa","Czwartek","Piątek","Sobota","Niedziela")
    //1.a (w funkcji to zrobić)
    println("1.a Pętla for - Wszystkie dni tygodnia:")
    for ( x <- daysArray ) {
      print(x +",")
    }

    //1.b (w funkcji to zrobić)
    println("\n1.b Dni tygodnia zaczynające się na literkę P:")
    for ( x <- daysArray ) {
      if (x.charAt(0).==('P')){
        println(x)
      }
    }
    
    //1.c (w funkcji to zrobić)
    println("\n1.c Pętla while - Wszystkie dni tygodnia:")
    var i = 0
    val s = daysArray.size

    while (i < s) {
      println(daysArray(i))
      i += 1
    }
    
    //2.a
    println("\n2.a Funkcja rekurencyjna - łączenie średnikiem:")
    def concatencateDaysRec(some_list: Array[String] ,  some_string: String): String = {
      if(some_list.length > 1){
        return concatencateDaysRec(some_list.tail,some_string + some_list(0) + ",")
      }
      else{
        return some_string + some_list(0)
      }
    }
    
    val stringOfDays: String = concatencateDaysRec(daysArray, "")
    println(stringOfDays)
  
    //2.b
    println("\n2.b Funkcja rekurencyjna elementy od końca listy - łączenie średnikiem:")
    def odwrotnie(some_list: Array[String] ,  some_string: String): String = {
      if(some_list.length > 1){
        return odwrotnie(some_list.slice(0,some_list.length-1),some_string + some_list.last + ";")
      }
      else{
        return some_string + some_list.last
      }
    }
    
    val odwrotniestringOfDays: String = odwrotnie(daysArray, "")
    println(odwrotniestringOfDays)
    
    //3
    println("\n3 Funkcja rekurencyjna ogonowa - łączenie średnikiem:")
    def factorial(some_list: Array[String] ): String = {
      @tailrec
      def insidemethod(some_list: Array[String] ,  some_string: String): String = {
        if(some_list.length > 1){
          return insidemethod(some_list.tail,some_string + some_list(0) + ";")
        }
        else{
          return some_string + some_list(0)
        }
      }
      insidemethod(some_list,"")
    }
    
    val tailrec: String = factorial(daysArray)
    println(tailrec)
    
    //4.a	Metody foldlLeft
    println("\n4.a Metody foldLeft - łączenie średnikiem:")
    println(daysArray.foldLeft("")((acc, s) => 
      if(s.contains("Niedziela")) acc + s
      else acc + s + ";"
      ))
      
    //4.b	Metody foldRight
    println("\n4.a Metody foldRight - łączenie średnikiem:")
    println(daysArray.foldRight("")((acc, s) => 
      if(s.contains("Poniedziałek"))acc + s
      else acc + ";" + s
      ))
      
    //4.c	Metody foldlLeft - tylko dni zaczynające się na "P"
    println("\n4.a Metody foldLeft - Dni tygodnia zaczynające się na literkę P")
    println(daysArray.foldLeft("")((acc, s) => 
      if(s.charAt(0).==('P')) acc + s + ";"
      else acc
      ))

    //5. Stwórz mapę z nazwami produktów i cenami. Na jej podstawie wygeneruj drugą, z 10% obniżką cen. 
      println("\n5 Mapowanie produktów:")
      val input: Map[String, Double] = Map(("Masło", 6), ("Mleko",3), ("Miód", 7), ("Woda", 2), ("Cukier", 5))
      val incM = input map {case (key, value) => (key, value * 0.9)}
      
      for ( x <- incM ) {
        println( x )
      }
      
    //6. Zdefiniuj funkcję przyjmującą krotkę z 3 wartościami różnych typów i wypisującą je
      println("\n6 Krotka z trzema typami:")
      val ingredient = ("Jabłko" , 25, 5.7): Tuple3[String, Int, Double]
      println(ingredient._1) 
      println(ingredient._2) 
      println(ingredient._3) 
      
    //7. Zaprezentuj działanie Option na dowolnym przykładzie (np. mapy, w której wyszukujemy wartości po kluczu)
     println("\n7 Option:")
      val capitals = Map("France" -> "Paris", "Japan" -> "Tokyo")
      
      println("show(capitals.get( \"Japan\")) : " + show(capitals.get( "Japan")) )
      println("show(capitals.get( \"India\")) : " + show(capitals.get( "India")) )

     def show(x: Option[String]) = x match {
       case Some(s) => s
       case None => "?"
     }
      
    //8	Napisz funkcję usuwającą zera z listy wartości całkowitych (tzn. zwracającą listę elementów mających wartości różne od 0).  
    //   Wykorzystaj rekurencję. 
    var intList = List(1,56,67,0,45,4,0,35,0,8,0)
    
    def removeZero(some_list: Array[Int], new_list: Array[Int]): Array[Int] = {
      if(some_list.lengt) > 0)
      {
        if(some_list.head.equals(0)){
          removeZero(some_list.tail,new_list)
        }
        else{
          removeZero(some_list.tail,new_list :+ some_list.head)
        }
      }
      else
        new_list
    }
  }
}