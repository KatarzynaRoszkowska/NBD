import scala.annotation.tailrec

object DaysOfTheWeek {
  def main(args: Array[String]): Unit ={
    var daysArray = List("Poniedziałek", "Wtorek", "Środa","Czwartek","Piątek","Sobota","Niedziela")
    
    //1.a
    println("1.a Pętla for - Wszystkie dni tygodnia:")
    println(connectElements_For(daysArray))
    
    //1.b
    println("\n1.b Pętla for - Dni tygodnia zaczynające się na literkę P:")
    println(connectElementsStartsWithP_For(daysArray))
    
    //1.c
    println("\n1.c Pętla while - Wszystkie dni tygodnia:")
    println(connectElements_While(daysArray))
    
    //2.a
    println("\n2.a Funkcja rekurencyjna - łączenie przecinkiem:")
    println(concatencateDaysRec(daysArray, ""))
    
    //2.b
    println("\n2.b Funkcja rekurencyjna elementy od końca listy - łączenie przecinkiem:")
    println(reverse(daysArray, ""))
    
    //3
    println("\n3 Funkcja rekurencyjna ogonowa - łączenie przecinkiem:")
    println(tailRec(daysArray))
    
    //4.a
    println("\n4.a Metoda foldLeft - łączenie przecinkiem:")
    println(daysFoldLeft(daysArray))
    
    //4.b
    println("\n4.a Metoda foldRight - łączenie przecinkiem:")
    
    
    // ---------------- FUNCTONS ---------------- //
    def connectElements_For(some_list: List[String]): String ={
      var acc = ""
      var size = some_list.length
      
      for ( x <- some_list ) {
         acc += x +","
      }
      acc.dropRight(1)
    }
    
    def connectElementsStartsWithP_For(some_list: List[String]): String ={
      var acc = ""
      
      for ( x <- some_list ) {
      if (x.charAt(0).==('P')){
        acc += x +","
      }
      }
      acc.dropRight(1)
    }

    def connectElements_While(some_list: List[String]): String ={
      var acc = ""
      var i = 0
      var size = daysArray.size
      
      while (i < size) {
        acc += daysArray(i) + ","
        i += 1
      }
      acc.dropRight(1)
    }
    
    def concatencateDaysRec(some_list: List[String] ,  some_string: String): String = {
      if(some_list.length > 1){
        return concatencateDaysRec(some_list.tail,some_string + some_list(0) + ",")
      }
      else{
        return some_string + some_list(0)
      }
    }
    
    def reverse(some_list: List[String] ,  some_string: String): String = {
      if(some_list.length > 1){
        return reverse(some_list.slice(0,some_list.length-1),some_string + some_list.last + ";")
      }
      else{
        return some_string + some_list.last
      }
    }
   
    def tailRec(some_list: List[String] ): String = {
      @tailrec
      def insideTailRec(some_list: List[String] ,  some_string: String): String = {
        if(some_list.length > 1){
          return insideTailRec(some_list.tail,some_string + some_list(0) + ";")
        }
        else{
          return some_string + some_list(0)
        }
      }
      insideTailRec(some_list,"")
    }
    
    def daysFoldLeft(some_list: List[String]): String ={
      var conStr = some_list.foldLeft("")((acc, s) => acc + s + ",")
      conStr.dropRight(1)
    }
      
    
    println(daysArray.foldRight("")((acc, s) => 
      if(s.contains("Poniedziałek"))acc + s
      else acc + ";" + s
      ))
      
    //4.c	Metody foldlLeft - tylko dni zaczynające się na "P"
    println("\n4.a Metody foldLeft - Dni tygodnia zaczynające się na literkę P")
    println(daysArray.foldLeft("")((acc, s) => 
      if(s.charAt(0).==('P')) acc + s + ";"
      else acc
      ))

    //5. Stwórz mapę z nazwami produktów i cenami. Na jej podstawie wygeneruj drugą, z 10% obniżką cen. 
      println("\n5 Mapowanie produktów:")
      val input: Map[String, Double] = Map(("Masło", 6), ("Mleko",3), ("Miód", 7), ("Woda", 2), ("Cukier", 5))
      val incM = input map {case (key, value) => (key, value * 0.9)}
      
      for ( x <- incM ) {
        println( x )
      }
      
    //6. Zdefiniuj funkcję przyjmującą krotkę z 3 wartościami różnych typów i wypisującą je
      println("\n6 Krotka z trzema typami:")
      val ingredient = ("Jabłko" , 25, 5.7): Tuple3[String, Int, Double]
      println(ingredient._1) 
      println(ingredient._2) 
      println(ingredient._3) 
      
    //7. Zaprezentuj działanie Option na dowolnym przykładzie (np. mapy, w której wyszukujemy wartości po kluczu)
     println("\n7 Option:")
      val capitals = Map("France" -> "Paris", "Japan" -> "Tokyo")
      
      println("show(capitals.get( \"Japan\")) : " + show(capitals.get( "Japan")) )
      println("show(capitals.get( \"India\")) : " + show(capitals.get( "India")) )

     def show(x: Option[String]) = x match {
       case Some(s) => s
       case None => "?"
     }
      
    //8	Napisz funkcję usuwającą zera z listy wartości całkowitych (tzn. zwracającą listę elementów mających wartości różne od 0).  
    //   Wykorzystaj rekurencję. 
    println("\n8 Remove 0:")
    var intList = List(1,56,67,0,45,4,0,35,0,8,0)
    var empltyList = List()
    
    def removeZero(some_list: List[Int], new_list: List[Int]): List[Int] = {
      if(some_list.length > 0)
      {
        if(some_list.head.equals(0)){
          removeZero(some_list.tail,new_list)
        }
        else{
          removeZero(some_list.tail,new_list :+ some_list.head)
        }
      }
      else
        new_list
    }
    var x  = removeZero(intList,empltyList)
    for ( r <- x ) {
      print(r +",")
    }
    
    //9	Zdefiniuj funkcję, przyjmującą listę liczb całkowitych i zwracającą wygenerowaną na jej podstawie listę, 
    //w której wszystkie liczby zostały zwiększone o 1. Wykorzystaj mechanizm mapowania kolekcji.
    println("\n 9 List with map:")
    def addOneToList(some_list: List[Int]): List[Int] = 
    {
      return some_list.map(x => x+1); 
    }
    
    var mapList  = addOneToList(intList)
    for ( r <- mapList ) {
      print(r +",")
    }
    
    //10 Stwórz funkcję przyjmującą listę liczb rzeczywistych i zwracającą stworzoną na jej podstawie 
    //listę zawierającą wartości bezwzględne elementów z oryginalnej listy należących do przedziału <-5,12>. 
    //Wykorzystaj filtrowanie.
     println("\n 10 List with filter:")
     
     def xxx(some_list: List[Int]): List[Int] = {
       some_list.filter(x => (x>= -5 && x <= 12))
     }
     var fList = List(1,-56,67,11,-45,-4,0,35,0,-8,2)
     var filterList  = xxx(fList)
      for ( r <- filterList ) {
        print(r +",")
      }  
  }
}